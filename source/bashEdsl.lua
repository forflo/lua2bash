dbg = require "debugger"

local function max(x, y)
    if x > y then return x
    else return y end
end

local bdsl = {}
bdsl.types = { EVAL = {}, BASE = {}, STRING = {}, CONC = {} }

local mtab = {}
local dslObjects = {}

mtab.__call = function(callee, arg)
    return callee:render(arg)
end
mtab.__concat = function(l, r)
    assert(l and r, "Arguments must not be nil")
    assert((getmetatable(l) == mtab or type(l) == "string") and
            (getmetatable(r) == mtab or type(r) == "string"),
        "Arguments must have been generated by bash EDSL functions\n" ..
            "type left: " .. type(l) .. " type right: " .. type(r))
    if type(l) == "string" then
        l = dslObjects.String(l)
    end
    if type(r) == "string" then
        r = dslObjects.String(r)
    end
    return dslObjects.Concat(l, r)
end

function dslObjects.Concat(left, right)
    local t = {}
    t._left = left
    t._type = bdsl.types.CONC
    t._right = right
    function t:render()
        return self:getLeft():render() .. self:getRight():render()
    end
    function t:shallowLift(n)
        if not n then n = 1 end
        self:getLeft():shallowLift(n)
        self:getRight():shallowLift(n)
        return self
    end
    function t:deepLift(n)
        if not n then n = 1 end
        self:getLeft():deepLift(n)
        self:getRight():deepLift(n)
        return self
    end
    function t:getType() return self._type end
    function t:getLeft() return self._left end
    function t:getRight() return self._right end
    function t:getQuotingIndex()
        return max(self:getLeft():getQuotingIndex(),
                   self:getRight():getQuotingIndex())
    end
    setmetatable(t, mtab)
    return t
end

local function settify(activeChars)
    local charSet = {}
    for _, v in pairs(activeChars) do
        charSet[v] = true
    end
    return charSet
end

function dslObjects.Base(activeChars, begin, ending, dslobj)
    local t = {}
    t._activeChars = settify(activeChars)
    t._type = bdsl.types.BASE
    t._begin = begin
    t._dependentQuoting = true
    t._subtree = nil
    t._end = ending
    if type(dslobj) == "string" then
        t._subtree = dslObjects.String(dslobj)
    else
        t._subtree = dslobj
    end
    t._quotingIndex = t._subtree:getQuotingIndex() + 1
    -- member functions
    function t:shallowLift(n)
        if not n then n = 1 end
        self._quotingIndex = self._quotingIndex + n
        return self
    end
    function t:deepLift(n)
        if not n then n = 1 end
        self:shallowLift(n)
        self:getSubtree():deepLift(n)
        return self
    end
    function t:setQuotingIndex(n)
        if not n then n = 1 end
        self._quotingIndex = n
        return self
    end
    function t:noDependentQuoting()
        self._dependentQuoting = false
        self._quotingIndex = t._subtree:getQuotingIndex()
        return self
    end
    function t:getQuotingIndex()
        return self._quotingIndex
    end
    --
    function t:getType() return self._type end
    function t:getActiveChars() return self._activeChars end
    function t:getBegin() return self._begin end
    function t:getEnd() return self._end end
    function t:getSubtree() return self._subtree end
    function t:render()
        local result, middle = "", self:getSubtree():render()
        local ac, begin, ending =
            self:getActiveChars(), self:getBegin(), self:getEnd()
        local nesting, repCount = self:getQuotingIndex(), nil
        if nesting > 0  and self._dependentQuoting then
            repCount = 2 ^ (nesting - 1) - 1
        elseif not self._dependenQuoting then
            repCount = 1
        else
            repCount = 0
        end
        for c in begin:gmatch(".") do
            if ac[c] then result = result .. string.rep("\\", repCount) .. c
            else result = result .. c end
        end
        result = result .. middle
        for c in ending:gmatch(".") do
            if ac[c] then result = result .. string.rep("\\", repCount) .. c
            else result = result .. c end
        end
        return result
    end
    -- write only
    function t:sL(n) return self:shallowLift(n) end
    function t:dL(n) return self:deepLift(n) end
    function t:noDep() return self:noDependentQuoting() end
    function t:sQ(n) return self:setQuotingIndex(n) end
    setmetatable(t, mtab)
    return t
end

function dslObjects.String(str)
    local t = {}
    t._content = str
    t._quotingIndex = 0
    t._type = bdsl.types.STRING
    function t:getType() return self._type end
    function t:shallowLift(n) return self end
    function t:deepLift(n) return self end
    function t:getQuotingIndex() return 0 end
    function t:getSubtree() return nil end
    function t:setQuotingIndex(n)
        if not n then n = 1 end
        self._quotingIndex = n
        return self
    end
    -- all chars will be prepended by an appropriate amount
    -- of backslash quotes depending on the quoting index
    function t:render()
        local repCount = 2 ^ self._quotingIndex - 1
        local result = ""
        for c in self._content:gmatch(".") do
            result = result .. string.rep("\\", repCount) .. c
        end
        return result
    end
    -- write only
    function t:sL(n) return self:shallowLift(n) end
    function t:dL(n) return self:deepLift(n) end
    function t:sQ(n) return self:setQuotingIndex(n) end
    setmetatable(t, mtab)
    return t
end


function dslObjects.Eval(dslobj)
    local t = {}
    t._subtree = nil
    t._type = bdsl.types.EVAL
    if type(dslobj) == "string" then
        t._subtree = dslObjects.String(dslobj)
    else
        t._subtree = dslobj
    end
    t._evalCountMin = 0
    t._evalThreshold = 1
    t._evalCount = t._subtree:getQuotingIndex() - t._evalThreshold
    -- member functions
    function t:shallowLift(n) return self end
    function t:deepLift(n)
        if not n then n = 1 end
        t:getSubtree():deepLift(n)
        return self
    end
    function t:evalLift(n)
        if not n then n = 1 end
        self._evalCount = self._evalCount + n
        return self
    end
    function t:evalThreshold(n)
        if not n then n = 1 end
        self._evalThreshold = n
        return self
    end
    function t:evalMin(n)
        if not n then n = 1 end
        self._evalCountMin = n
        return self
    end
    function t:getSubtree() return self._subtree end
    function t:getEvalCountMin() return self._evalCountMin end
    function t:getEvalThreshold() return self._evalThreshold end
    function t:getType() return self._type end
    function t:getQuotingIndex()
        return self:getSubtree():getQuotingIndex() end
    function t:getEvalCount() return self._evalCount end
    function t:render()
        local evalCount = self:getQuotingIndex() - self:getEvalThreshold()
        local rest = self:getSubtree():render()
        if evalCount < self:getEvalCountMin() then
            evalCount = self:getEvalCountMin()
        end
        return string.rep("eval ", evalCount) .. rest
    end
    -- write only
    function t:sL(n) return self:shallowLift(n) end
    function t:dL(n) return self:deepLift(n) end
    function t:eL(n) return self:evalLift(n) end
    function t:eM(n) return self:evalMin(n) end
    function t:eT(n) return self:evalThreshold(n) end
    setmetatable(t, mtab)
    return t
end

local function bDslEval(dslobj)
    return dslObjects.Eval(dslobj)
end

local function bDslString(str)
    return dslObjects.String(str)
end

local function bDslParentheses(dslobj)
    return dslObjects.Base({"(", ")"}, "(", ")", dslobj)
end

local function bDslParamExpansion(str)
    return dslObjects.Base({"$"}, "${", "}", str)
end

local function bDslSingleQuotes(str)
    return dslObjects.Base({"'"}, "'", "'", str)
end

local function bDslArithExpansion(str)
    return dslObjects.Base({"$", "(", ")"}, "$((", "))", str)
end

local function bDslDoubleQuotes(str)
    return dslObjects.Base({[["]]}, "\"", "\"", str)
end

local function bDslCommandExpansionTicks(str)
    return dslObjects.Base({"`"}, "`", "`", str)
end

local function bDslCommandExpansionParen(str)
    return dslObjects.Base({"$", "(", ")"}, "$(", ")", str)
end

local function bDslBraceExpansion(str)
    return dslObjects.Base({"{", "}"}, "{", "}", str)
end

local function bDslProcessExpansionIn(str)
    return dslObjects.Base({"<", "(", ")"}, "<(", ")", str)
end

local function bDslProcessExpansionOut(str)
    return dslObjects.Base({">", ")", "("}, ">(", ")", str)
end

-- better readability
bdsl.eval = bDslEval
bdsl.string = bDslString
bdsl.paramExpansion = bDslParamExpansion
bdsl.singleQuotes = bDslSingleQuotes
bdsl.doubleQuotes = bDslDoubleQuotes
bdsl.processExpansionIn = bDslProcessExpansionIn
bdsl.processExpansionOut = bDslProcessExpansionOut
bdsl.cmdExpansionParen = bDslCommandExpansionParen
bdsl.cmdExpansionTicks = bDslCommandExpansionTicks
bdsl.arithExpansion = bDslArithExpansion
bdsl.braceExpansion = bDslBraceExpansion
bdsl.parentheses = bDslParentheses

-- write only
bdsl.e = bDslEval
bdsl.s = bDslString
bdsl.pE = bDslParamExpansion
bdsl.sQ = bDslSingleQuotes
bdsl.dQ = bDslDoubleQuotes
bdsl.pEI = bDslProcessExpansionIn
bdsl.pEO = bDslProcessExpansionOut
bdsl.cEP = bDslCommandExpansionParen
bdsl.cET = bDslCommandExpansionTicks
bdsl.aE = bDslArithExpansion
bdsl.bE = bDslBraceExpansion
bdsl.p = bDslParentheses

return bdsl
